### Experimentelle Makefile von Jidder. Bei Problemen: pech :P ^^
# .nobuild-Dateien müssen folgendes enthalten: $(eval $(NOBUILD))

ARCH ?= i386

LDFLAGS_KERNEL := -T src/kernel/src/kernel.ld
LDFLAGS_MODULES := -m elf_i386 -Ttext=0x40000000

LDFLAGS_KERNEL2 := -T src/kernel2/src/arch/$(ARCH)/kernel.ld

CPPFLAGS += -Isrc/include -Isrc/include/arch/$(ARCH)

OBJCOPY = objcopy

# Alle Module im Verzeichnis src/modules
MODULES := $(filter-out c include lib,$(notdir $(wildcard src/modules/*)))
# Alle Anwendungen
APPS := $(notdir $(wildcard src/modules/c/*))

all: lib kernel modules apps

clean:
	-rm -f $(ALL_LIBS) build/lost.krn build/lost.kgz $(ALL_MODULES) $(ALL_MODULES:.mod=.mgz) $(ALL_OBJS)


### Eine Regel für .asm-Dateien, da es keine eingebaute gibt
NASM := nasm
NASMFLAGS := -f elf

%.o: %.asm
	$(NASM) $(NASMFLAGS) $< -o $@


### Hilfsfunktionen/-makros
# Unterstützte Dateiendungen
EXTENSIONS := .asm .S .c .cpp
# $(call SOURCE_FILES,dir) gibt alle Quelltext-Dateien im Verzeichnis dir zurück
SOURCE_FILES = $(wildcard $(addprefix $(1)/*,$(EXTENSIONS)))
# $(call OBJECT_FILES,foo.c bar.asm baz.cpp) gibt "foo.o bar.o baz.o" zurück
OBJECT_FILES = $(addsuffix .o,$(basename $(1)))
# $(call SOURCE_FILES_WILDCARD,dir/*) gibt alle Quelltext-Dateien in den Unterverzeichnissen von dir zurück
SOURCE_FILES_WILDCARD = $(foreach dir,$(wildcard $(1)),$(call SOURCE_FILES,$(dir)))


### Kernel
kernel: build/lost.krn

KERNEL_SRC = $(call SOURCE_FILES,src/kernel/src) $(call SOURCE_FILES_WILDCARD,src/kernel/src/*)
KERNEL_OBJS = $(call OBJECT_FILES,$(KERNEL_SRC))
ALL_OBJS += $(KERNEL_OBJS)
build/lost.krn: $(KERNEL_OBJS) src/lib/library.a
	ld -o $@ $(LDFLAGS_KERNEL) $^
build/lost.krn: CPPFLAGS += -Isrc/kernel/include

zkernel: build/lost.kgz

-include src/kernel2/src/module.mk

build/%.kgz: build/%.krn
	cp -f $< $@
	gzip -f $@
	mv -f $@.gz $@

### Module
modules: $(MODULE_LIBS) $(MODULES:%=build/%.mod)
zmodules: $(MODULES:%=build/%.mgz)

define MODULE_template
define NOBUILD
build/$(1).mod: nobuild ;
build/$(1).mgz: nobuild ;
endef
MODULE_PATH := src/modules/$(1)
$(1)_SRC := $(call SOURCE_FILES,src/modules/$(1))
$(1)_OBJS := $$(call OBJECT_FILES,$$($(1)_SRC))
-include src/modules/$(1)/module.mk
build/$(1).mod: CPPFLAGS += -Isrc/modules/$(1)/include -Isrc/modules/include
build/$(1).mod: $$($(1)_OBJS) src/modules/lib/library.a
	ld $(LDFLAGS_MODULES) $$^ -o $$@ `gcc -print-libgcc-file-name`
-include src/modules/$(1)/.nobuild
ALL_OBJS += $$($(1)_OBJS)
ALL_MODULES += build/$(1).mod
endef

build/%.mgz: build/%.mod
	cp -f $< $@
	gzip -f $@
	mv -f $@.gz $@

$(foreach module,$(MODULES),$(eval $(call MODULE_template,$(module))))


### Anwendungen (praktisch wie Module nur in anderen Verzeichnissen)
apps: $(MODULE_LIBS) $(APPS:%=build/apps/%)

define APPS_template
NOBUILD = build/apps/$(1): nobuild ;
MODULE_PATH := src/modules/c/$(1)
$(1)_SRC := $(call SOURCE_FILES,src/modules/c/$(1))
$(1)_OBJS := $$(call OBJECT_FILES,$$($(1)_SRC))
-include src/modules/c/$(1)/module.mk
build/apps/$(1): CPPFLAGS += -Isrc/modules/c/$(1)/include -Isrc/modules/include
build/apps/$(1): $$($(1)_OBJS) src/modules/lib/library.a
	ld $(LDFLAGS_MODULES) $$^ -o $$@ `gcc -print-libgcc-file-name`
-include src/modules/c/$(1)/.nobuild
ALL_OBJS += $$($(1)_OBJS)
ALL_MODULES += build/apps/$(1)
endef

$(foreach app,$(APPS),$(eval $(call APPS_template,$(app))))


nobuild:

### Libraries
lib: src/lib/library.a src/modules/lib/library.a

### Library die in den Kernel und die Module gelinkt wird
LIB_SRC = $(call SOURCE_FILES,src/lib) $(call SOURCE_FILES_WILDCARD,src/lib/*)
LIB_OBJS = $(call OBJECT_FILES,$(LIB_SRC))
ALL_OBJS += $(LIB_OBJS)
ALL_LIBS += src/lib/library.a
src/lib/library.a: $(LIB_OBJS)
	$(AR) rs $@ $^

### Library die nur in die Module gelinkt wird
MODULES_LIB_SRC = $(call SOURCE_FILES,src/modules/lib) $(call SOURCE_FILES_WILDCARD,src/modules/lib/*) $(call SOURCE_FILES_WILDCARD,src/modules/lib/*/*)
MODULES_LIB_OBJS = $(call OBJECT_FILES,$(MODULES_LIB_SRC))
ALL_OBJS += $(MODULES_LIB_OBJS)
ALL_LIBS += src/modules/lib/library.a
src/modules/lib/library.a: $(MODULES_LIB_OBJS) $(LIB_OBJS)
	$(AR) rs $@ $^
src/modules/lib/library.a: CPPFLAGS += -Isrc/modules/include -Isrc/modules/lib/lostio/include


### Disketten-Image erstellen
image: build/lost.img zkernel zmodules apps
	mcopy -D o -i build/lost.img build/default.cfg ::/grub/menu.lst
	mcopy -D o -i build/lost.img build/*.kgz ::/
	mcopy -D o -i build/lost.img build/*.mgz ::/
	mcopy -D o -i build/lost.img build/apps ::/

build/lost.img:
	dd if=/dev/zero of=build/lost.img bs=1024 count=1440
	/sbin/mkfs.msdos build/lost.img
	mmd -i build/lost.img ::/grub
	mcopy -i build/lost.img /boot/grub/stage? ::/grub
	mcopy -i build/lost.img build/default.cfg ::/grub/menu.lst
	echo device '(fd0)' build/lost.img > build/grub.txt
	echo root '(fd0)' >> build/grub.txt
	echo setup '(fd0)' >> build/grub.txt
	grub --batch < build/grub.txt
	rm build/grub.txt

build/lost.img: PATH:=$(PATH):/sbin:/usr/sbin:/usr/local/sbin
